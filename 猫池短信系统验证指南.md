# 猫池短信系统功能验证计划（Mac开发版）

## 🎯 开发策略：Mac开发 → Windows部署

```
Mac模拟开发 → 功能完善 → 跨平台测试 → Windows实机调试 → 生产部署
```

---

## 📋 第一阶段：Mac平台模拟环境搭建

### 1.1 Mac串口模拟解决方案

#### 方案一：socat虚拟串口（推荐）
```bash
# 安装socat（如未安装）
brew install socat

# 创建虚拟串口对
socat -d -d pty,raw,echo=0 pty,raw,echo=0
# 会输出类似：
# 2024/01/01 12:00:00 socat[12345] N PTY is /dev/ttys001
# 2024/01/01 12:00:00 socat[12346] N PTY is /dev/ttys002
```

#### 方案二：Python虚拟串口服务器
```python
# 创建文件：tests/mac_serial_simulator.py
import threading
import socket
import time
import random
from typing import Dict, List, Optional
import json
from dataclasses import dataclass

@dataclass
class MockModemInfo:
    port_name: str
    operator: str  # 移动、联通、电信
    imei: str
    signal_strength: int  # 1-31
    success_rate: float   # 0.0-1.0
    current_status: str   # idle, busy, error
    send_count: int = 0
    error_count: int = 0
    last_active: float = 0

class MacSerialSimulator:
    """Mac平台串口模拟器"""
    
    def __init__(self):
        self.modems = self._create_mock_modems()
        self.socket_server = None
        self.is_running = False
        self.clients = {}  # port_name -> socket
        
    def _create_mock_modems(self) -> Dict[str, MockModemInfo]:
        """创建模拟猫池设备"""
        modems = {}
        operators = ['移动', '联通', '电信']
        
        for i in range(1, 9):  # 创建8个模拟端口
            port_name = f"/dev/ttys{i:03d}"  # Mac风格端口名
            operator = operators[i % 3]
            
            modems[port_name] = MockModemInfo(
                port_name=port_name,
                operator=operator,
                imei=f"86012345678901{i:02d}",
                signal_strength=random.randint(15, 31),
                success_rate=random.uniform(0.85, 0.98),
                current_status='idle'
            )
        
        return modems
    
    def start_simulator(self, host='localhost', port=8888):
        """启动模拟器服务"""
        self.socket_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket_server.bind((host, port))
        self.socket_server.listen(10)
        
        self.is_running = True
        
        print(f"🚀 Mac串口模拟器启动在 {host}:{port}")
        print(f"📱 模拟设备数量: {len(self.modems)}")
        
        # 打印模拟设备信息
        for modem in self.modems.values():
            print(f"  📲 {modem.port_name} [{modem.operator}] 信号:{modem.signal_strength}/31")
        
        # 启动服务线程
        threading.Thread(target=self._handle_connections, daemon=True).start()
        
        # 启动状态监控线程
        threading.Thread(target=self._status_monitor, daemon=True).start()
    
    def _handle_connections(self):
        """处理客户端连接"""
        while self.is_running:
            try:
                client_socket, address = self.socket_server.accept()
                print(f"📞 新连接来自: {address}")
                
                # 为每个连接启动处理线程
                threading.Thread(
                    target=self._handle_client,
                    args=(client_socket, address),
                    daemon=True
                ).start()
            except Exception as e:
                if self.is_running:
                    print(f"❌ 连接处理错误: {e}")
    
    def _handle_client(self, client_socket, address):
        """处理单个客户端"""
        try:
            while self.is_running:
                # 接收AT指令
                data = client_socket.recv(1024).decode('utf-8', errors='ignore')
                if not data:
                    break
                
                # 解析并响应AT指令
                response = self._process_at_command(data.strip(), address)
                client_socket.send(response.encode('utf-8'))
                
        except Exception as e:
            print(f"❌ 客户端处理错误 {address}: {e}")
        finally:
            client_socket.close()
            print(f"📴 连接断开: {address}")
    
    def _process_at_command(self, command: str, address) -> str:
        """处理AT指令"""
        # 基本的AT指令响应
        at_responses = {
            'AT': 'OK',
            'ATI': 'Mock Modem v1.0',
            'AT+CIMI': '460001234567890',  # 模拟IMSI
            'AT+CGSN': '860123456789012',  # 模拟IMEI
            'AT+CSQ': '+CSQ: 25,99',       # 模拟信号强度
            'AT+CREG?': '+CREG: 0,1',      # 模拟网络注册状态
        }
        
        # 短信发送指令
        if command.startswith('AT+CMGS='):
            return self._simulate_sms_send(command, address)
        
        # 返回标准响应
        return at_responses.get(command, 'ERROR')
    
    def _simulate_sms_send(self, command: str, address) -> str:
        """模拟短信发送"""
        # 随机选择一个模拟设备
        modem = random.choice(list(self.modems.values()))
        
        # 更新设备状态
        modem.current_status = 'busy'
        modem.last_active = time.time()
        
        # 模拟发送延迟
        time.sleep(random.uniform(0.5, 2.0))
        
        # 模拟发送结果
        success = random.random() < modem.success_rate
        
        if success:
            modem.send_count += 1
            modem.current_status = 'idle'
            message_id = f"MSG{int(time.time())}{random.randint(1000,9999)}"
            return f'+CMGS: {message_id}\nOK'
        else:
            modem.error_count += 1
            modem.current_status = 'error'
            error_codes = ['300', '301', '302', '303', '304']  # CMS错误码
            error_code = random.choice(error_codes)
            return f'+CMS ERROR: {error_code}'
    
    def _status_monitor(self):
        """状态监控线程"""
        while self.is_running:
            time.sleep(10)  # 每10秒更新一次状态
            
            # 随机更新设备状态
            for modem in self.modems.values():
                if modem.current_status == 'error':
                    # 错误状态有概率恢复
                    if random.random() < 0.3:
                        modem.current_status = 'idle'
                
                # 更新信号强度
                modem.signal_strength = max(1, min(31, 
                    modem.signal_strength + random.randint(-2, 2)))
    
    def get_status(self) -> dict:
        """获取所有设备状态"""
        status = {
            'total_modems': len(self.modems),
            'active_modems': sum(1 for m in self.modems.values() if m.current_status == 'idle'),
            'busy_modems': sum(1 for m in self.modems.values() if m.current_status == 'busy'),
            'error_modems': sum(1 for m in self.modems.values() if m.current_status == 'error'),
            'total_sent': sum(m.send_count for m in self.modems.values()),
            'total_errors': sum(m.error_count for m in self.modems.values()),
            'modems': []
        }
        
        for modem in self.modems.values():
            status['modems'].append({
                'port': modem.port_name,
                'operator': modem.operator,
                'status': modem.current_status,
                'signal': modem.signal_strength,
                'sent': modem.send_count,
                'errors': modem.error_count
            })
        
        return status
    
    def stop_simulator(self):
        """停止模拟器"""
        self.is_running = False
        if self.socket_server:
            self.socket_server.close()
        print("🛑 Mac串口模拟器已停止")

# 模拟器启动脚本
if __name__ == '__main__':
    simulator = MacSerialSimulator()
    
    try:
        simulator.start_simulator()
        
        print("\n📋 可用命令:")
        print("  status - 查看设备状态")
        print("  quit   - 退出模拟器")
        
        while True:
            cmd = input("\n> ").strip().lower()
            if cmd == 'quit':
                break
            elif cmd == 'status':
                status = simulator.get_status()
                print(f"\n📊 设备状态:")
                print(f"  总设备: {status['total_modems']}")
                print(f"  空闲: {status['active_modems']}")
                print(f"  忙碌: {status['busy_modems']}")
                print(f"  错误: {status['error_modems']}")
                print(f"  总发送: {status['total_sent']}")
                print(f"  总错误: {status['total_errors']}")
            else:
                print("❓ 未知命令")
    
    except KeyboardInterrupt:
        pass
    finally:
        simulator.stop_simulator()
```

### 1.2 Mac平台端口检测适配
```python
# 创建文件：core/mac_port_scanner.py
import glob
import serial
from typing import List, Dict
import platform
import subprocess

class MacPortScanner:
    """Mac平台端口扫描器"""
    
    def __init__(self):
        self.system = platform.system()
    
    def scan_available_ports(self) -> List[Dict[str, str]]:
        """扫描可用串口"""
        ports = []
        
        if self.system == 'Darwin':  # macOS
            # Mac串口通常在 /dev/tty.* 或 /dev/cu.*
            tty_ports = glob.glob('/dev/tty.*')
            cu_ports = glob.glob('/dev/cu.*')
            
            # 合并并过滤
            all_ports = tty_ports + cu_ports
            
            # 过滤出USB设备和蓝牙设备
            usb_ports = [p for p in all_ports if 'usb' in p.lower() or 'serial' in p.lower()]
            bluetooth_ports = [p for p in all_ports if 'bluetooth' in p.lower()]
            
            # 模拟设备端口（开发阶段）
            mock_ports = [f'/dev/ttys{i:03d}' for i in range(1, 9)]
            
            for port_path in usb_ports + bluetooth_ports + mock_ports:
                port_info = self._get_port_info(port_path)
                if port_info:
                    ports.append(port_info)
        
        return ports
    
    def _get_port_info(self, port_path: str) -> Dict[str, str]:
        """获取端口详细信息"""
        try:
            # 尝试打开端口获取信息
            with serial.Serial(port_path, 9600, timeout=1) as ser:
                port_info = {
                    'port': port_path,
                    'description': self._get_port_description(port_path),
                    'manufacturer': 'Unknown',
                    'product': 'Unknown',
                    'hwid': port_path,
                    'status': 'available'
                }
                
                # 如果是模拟端口，添加模拟信息
                if 'ttys' in port_path:
                    port_info.update({
                        'description': f'Mock Modem Port {port_path.split("/")[-1]}',
                        'manufacturer': 'Mock Devices Inc.',
                        'product': 'Virtual SMS Modem',
                        'status': 'mock'
                    })
                
                return port_info
                
        except (serial.SerialException, PermissionError):
            # 端口被占用或无权限
            return {
                'port': port_path,
                'description': 'Port busy or no permission',
                'status': 'unavailable'
            }
    
    def _get_port_description(self, port_path: str) -> str:
        """获取端口描述"""
        try:
            # 使用系统命令获取设备信息
            result = subprocess.run([
                'system_profiler', 'SPUSBDataType', '-xml'
            ], capture_output=True, text=True)
            
            # 简化处理，实际可以解析XML获取详细信息
            if 'usb' in port_path.lower():
                return 'USB Serial Device'
            elif 'bluetooth' in port_path.lower():
                return 'Bluetooth Serial Device'
            else:
                return 'Serial Device'
                
        except:
            return 'Unknown Serial Device'
    
    def test_port_communication(self, port_path: str) -> Dict[str, any]:
        """测试端口通信"""
        try:
            with serial.Serial(port_path, 9600, timeout=2) as ser:
                # 发送AT指令测试
                ser.write(b'AT\r\n')
                response = ser.readline().decode('utf-8', errors='ignore').strip()
                
                if 'OK' in response:
                    return {
                        'success': True,
                        'response': response,
                        'type': 'modem'
                    }
                else:
                    return {
                        'success': False,
                        'error': 'No AT response',
                        'response': response
                    }
                    
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
```

### 1.3 跨平台适配层
```python
# 创建文件：core/platform_adapter.py
import platform
from abc import ABC, abstractmethod
from typing import List, Dict

class PlatformAdapter(ABC):
    """平台适配器基类"""
    
    @abstractmethod
    def get_available_ports(self) -> List[Dict]:
        pass
    
    @abstractmethod
    def create_serial_connection(self, port: str, baudrate: int):
        pass
    
    @abstractmethod
    def get_system_info(self) -> Dict:
        pass

class MacAdapter(PlatformAdapter):
    """Mac平台适配器"""
    
    def get_available_ports(self) -> List[Dict]:
        from core.mac_port_scanner import MacPortScanner
        scanner = MacPortScanner()
        return scanner.scan_available_ports()
    
    def create_serial_connection(self, port: str, baudrate: int):
        import serial
        return serial.Serial(port, baudrate, timeout=1)
    
    def get_system_info(self) -> Dict:
        return {
            'platform': 'macOS',
            'version': platform.mac_ver()[0],
            'architecture': platform.machine(),
            'python_version': platform.python_version()
        }

class WindowsAdapter(PlatformAdapter):
    """Windows平台适配器"""
    
    def get_available_ports(self) -> List[Dict]:
        import serial.tools.list_ports
        ports = []
        for port in serial.tools.list_ports.comports():
            ports.append({
                'port': port.device,
                'description': port.description,
                'manufacturer': getattr(port, 'manufacturer', 'Unknown'),
                'product': getattr(port, 'product', 'Unknown'),
                'hwid': port.hwid,
                'status': 'available'
            })
        return ports
    
    def create_serial_connection(self, port: str, baudrate: int):
        import serial
        return serial.Serial(port, baudrate, timeout=1)
    
    def get_system_info(self) -> Dict:
        return {
            'platform': 'Windows',
            'version': platform.version(),
            'architecture': platform.machine(),
            'python_version': platform.python_version()
        }

# 平台适配器工厂
def get_platform_adapter() -> PlatformAdapter:
    system = platform.system()
    if system == 'Darwin':
        return MacAdapter()
    elif system == 'Windows':
        return WindowsAdapter()
    else:
        raise NotImplementedError(f"Unsupported platform: {system}")
```

---

## 📋 第二阶段：Mac开发环境验证计划

### **第1批：基础环境验证（Day 1）**
```
🎯 目标：确保Mac环境基础设施正常
📂 文件：database/*, config/*, models/base.py
🧪 测试：数据库连接、配置加载、日志系统
🔧 模拟：PostgreSQL本地实例、测试配置
📊 成功标准：所有基础服务正常启动
```

### **第2批：平台适配验证（Day 1-2）**
```
🎯 目标：Mac平台特有功能正常工作
📂 文件：core/mac_port_scanner.py, core/platform_adapter.py
🧪 测试：端口扫描、平台检测、虚拟设备识别
🔧 模拟：虚拟串口、模拟设备信息
📊 成功标准：能正确识别和操作虚拟端口
```

### **第3批：用户认证验证（Day 2-3）**
```
🎯 目标：登录和权限系统完整可用
📂 文件：services/auth_service.py, models/user.py, ui/login_window.py
🧪 测试：登录验证、MAC绑定（跳过）、会话管理
🔧 模拟：测试用户数据、跳过MAC验证标志
📊 成功标准：用户能成功登录并进入主界面
```

### **第4批：UI框架验证（Day 3-4）**
```
🎯 目标：主界面布局和基础交互正常
📂 文件：ui/main_window.py, ui/components/*
🧪 测试：界面布局、组件显示、事件响应
🔧 模拟：测试数据绑定、模拟状态更新
📊 成功标准：界面美观、响应流畅、无UI错误
```

### **第5批：端口管理核心（Day 4-5）**
```
🎯 目标：端口扫描、监控、控制功能完整
📂 文件：services/port_service.py, core/port_scanner.py
🧪 测试：端口发现、状态监控、启动停止控制
🔧 模拟：Mac串口模拟器、状态变化模拟
📊 成功标准：端口列表正确显示，状态实时更新
```

### **第6批：任务管理核心（Day 5-6）**
```
🎯 目标：任务完整生命周期管理
📂 文件：services/task_service.py, models/task.py, ui/dialogs/add_task_dialog.py
🧪 测试：任务创建、编辑、删除、状态变更
🔧 模拟：测试任务数据、虚拟号码文件
📊 成功标准：任务管理功能完整，数据持久化正确
```

### **第7批：消息发送模拟（Day 6-7）**
```
🎯 目标：消息发送流程和结果处理
📂 文件：core/message_sender.py, core/task_executor.py
🧪 测试：消息队列、发送调度、结果统计
🔧 模拟：串口模拟器、AT指令响应、发送结果
📊 成功标准：发送流程完整，统计数据正确
```

### **第8批：高级功能验证（Day 7-8）**
```
🎯 目标：导出、配置、监控等辅助功能
📂 文件：services/export_service.py, core/file_handler.py
🧪 测试：数据导出、文件处理、配置管理
🔧 模拟：测试导出数据、各种文件格式
📊 成功标准：辅助功能稳定可用
```

### **第9批：集成测试（Day 8-9）**
```
🎯 目标：完整业务流程端到端验证
📂 文件：全系统集成
🧪 测试：完整工作流、并发处理、异常恢复
🔧 模拟：压力测试、边界条件、故障注入
📊 成功标准：系统整体稳定，性能达标
```

---

## 🛠️ Mac开发环境快速搭建

### 创建Mac环境搭建脚本
```bash
#!/bin/bash
# 创建文件：setup_mac_dev_environment.sh

echo "🍎 开始搭建Mac开发环境..."

# 检查并安装必要工具
echo "📋 检查开发工具..."

# 检查Homebrew
if ! command -v brew &> /dev/null; then
    echo "📦 安装Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
fi

# 安装必要工具
echo "🔧 安装开发工具..."
brew install python@3.9 postgresql socat

# 检查Python环境
echo "🐍 检查Python环境..."
python3 --version
pip3 --version

# 创建虚拟环境
echo "📦 创建虚拟环境..."
python3 -m venv catpool_env
source catpool_env/bin/activate

# 安装依赖
echo "📚 安装Python依赖..."
pip install -r requirements.txt

# 启动PostgreSQL
echo "🗄️ 启动PostgreSQL..."
brew services start postgresql

# 创建数据库
echo "💾 创建数据库..."
createdb sms_pool_db 2>/dev/null || echo "数据库已存在"

# 导入数据库结构
echo "🏗️ 导入数据库结构..."
psql sms_pool_db < jlmisplus.sql

# 创建测试目录
echo "📁 创建测试目录..."
mkdir -p tests/mock temp/test_data temp/uploads/test temp/exports/test temp/logs

# 生成Mac特定配置
echo "⚙️ 生成Mac开发配置..."
cat > .env.mac << EOF
# Mac开发环境配置
DB_HOST=localhost
DB_PORT=5432
DB_NAME=sms_pool_db
DB_USER=$USER
DB_PASSWORD=

# 开发模式设置
DEBUG=true
TEST_MODE=true
PLATFORM=darwin

# Mac特定设置
SKIP_MAC_VERIFICATION=true
MOCK_SERIAL_PORTS=true
VIRTUAL_PORT_COUNT=8

# 日志设置
LOG_LEVEL=DEBUG
LOG_TO_FILE=true

# UI设置
USE_NATIVE_UI=true
WINDOW_SCALE=1.0
EOF

# 设置权限
echo "🔐 设置权限..."
chmod +x setup_mac_dev_environment.sh

echo "✅ Mac开发环境搭建完成！"
echo ""
echo "📋 下一步操作："
echo "1. source catpool_env/bin/activate  # 激活虚拟环境"
echo "2. cp .env.mac .env                  # 使用Mac配置"
echo "3. python tests/mac_serial_simulator.py  # 启动模拟器"
echo "4. python app.py                    # 启动应用"
```

### Mac开发专用测试运行器
```python
# 创建文件：run_mac_tests.py
#!/usr/bin/env python3
import os
import sys
import subprocess
import threading
import time
from pathlib import Path

class MacTestRunner:
    def __init__(self):
        self.simulator_process = None
        self.test_results = []
    
    def setup_environment(self):
        """设置Mac测试环境"""
        print("🍎 设置Mac测试环境...")
        
        # 确保使用Mac配置
        if Path('.env.mac').exists():
            import shutil
            shutil.copy('.env.mac', '.env')
            print("✅ 已切换到Mac开发配置")
        
        # 创建必要目录
        directories = [
            'tests/mock', 'temp/test_data', 'temp/mock_ports',
            'temp/uploads/test', 'temp/exports/test', 'temp/logs'
        ]
        
        for dir_path in directories:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
        
        print("✅ 测试目录创建完成")
    
    def start_simulator(self):
        """启动Mac串口模拟器"""
        print("🚀 启动串口模拟器...")
        
        try:
            # 在后台启动模拟器
            self.simulator_process = subprocess.Popen([
                sys.executable, 'tests/mac_serial_simulator.py'
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            
            # 等待模拟器启动
            time.sleep(2)
            
            if self.simulator_process.poll() is None:
                print("✅ 串口模拟器启动成功")
                return True
            else:
                print("❌ 串口模拟器启动失败")
                return False
                
        except Exception as e:
            print(f"❌ 启动模拟器时出错: {e}")
            return False
    
    def run_test_batch(self, batch_name: str, test_files: list):
        """运行测试批次"""
        print(f"\n🧪 运行测试批次: {batch_name}")
        print("=" * 50)
        
        batch_results = []
        
        for test_file in test_files:
            if Path(test_file).exists():
                print(f"▶️  运行: {test_file}")
                
                try:
                    result = subprocess.run([
                        sys.executable, '-m', 'pytest', test_file, '-v'
                    ], capture_output=True, text=True, timeout=60)
                    
                    success = result.returncode == 0
                    batch_results.append({
                        'file': test_file,
                        'success': success,
                        'output': result.stdout,
                        'error': result.stderr
                    })
                    
                    status = "✅ 通过" if success else "❌ 失败"
                    print(f"   {status}: {test_file}")
                    
                    if not success:
                        print(f"   错误: {result.stderr[:200]}")
                
                except subprocess.TimeoutExpired:
                    batch_results.append({
                        'file': test_file,
                        'success': False,
                        'output': '',
                        'error': 'Test timeout'
                    })
                    print(f"   ⏰ 超时: {test_file}")
                    
            else:
                print(f"   ⚠️  文件不存在: {test_file}")
                batch_results.append({
                    'file': test_file,
                    'success': False,
                    'output': '',
                    'error': 'File not found'
                })
        
        self.test_results.append({
            'batch': batch_name,
            'results': batch_results
        })
        
        # 批次结果统计
        total = len(batch_results)
        passed = sum(1 for r in batch_results if r['success'])
        print(f"\n📊 {batch_name} 结果: {passed}/{total} 通过")
        
        return passed == total
    
    def generate_report(self):
        """生成测试报告"""
        print("\n📋 生成测试报告...")
        
        report_lines = [
            "# Mac开发环境测试报告",
            f"生成时间: {time.strftime('%Y-%m-%d %H:%M:%S')}",
            f"平台: macOS ({os.uname().machine})",
            ""
        ]
        
        total_tests = 0
        total_passed = 0
        
        for batch in self.test_results:
            batch_name = batch['batch']
            batch_results = batch['results']
            
            batch_total = len(batch_results)
            batch_passed = sum(1 for r in batch_results if r['success'])
            
            total_tests += batch_total
            total_passed += batch_passed
            
            report_lines.extend([
                f"## {batch_name}",
                f"通过率: {batch_passed}/{batch_total} ({batch_passed/batch_total*100:.1f}%)",
                ""
            ])
            
            for result in batch_results:
                status = "✅" if result['success'] else "❌"
                report_lines.append(f"- {status} {result['file']}")
                
                if not result['success'] and result['error']:
                    report_lines.append(f"  错误: {result['error'][:100]}...")
            
            report_lines.append("")
        
        # 总体统计
        success_rate = (total_passed / total_tests * 100) if total_tests > 0 else 0
        report_lines.insert(4, f"总体通过率: {total_passed}/{total_tests} ({success_rate:.1f}%)")
        report_lines.insert(5, "")
        
        # 保存报告
        report_content = '\n'.join(report_lines)
        report_file = f"temp/logs/mac_test_report_{int(time.time())}.md"
        
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        print(f"📄 测试报告已保存: {report_file}")
        return report_file
    
    def cleanup(self):
        """清理资源"""
        if self.simulator_process:
            print("🛑 停止模拟器...")
            self.simulator_process.terminate()
            self.simulator_process.wait()
    
    def run_all_tests(self):
        """运行完整测试流程"""
        print("🍎 Mac开发环境完整测试开始")
        print("=" * 60)
        
        try:
            # 1. 设置环境
            self.setup_environment()
            
            # 2. 启动模拟器
            if not self.start_simulator():
                return False
            
            # 3. 运行测试批次
            test_batches = [
                ("基础环境", [
                    "tests/test_database.py",
                    "tests/test_config.py",
                    "tests/test_logging.py"
                ]),
                ("平台适配", [
                    "tests/test_mac_platform.py",
                    "tests/test_port_scanner.py"
                ]),
                ("用户认证", [
                    "tests/test_auth_service.py",
                    "tests/test_user_model.py"
                ]),
                ("界面框架", [
                    "tests/test_main_window.py",
                    "tests/test_ui_components.py"
                ]),
                ("任务管理", [
                    "tests/test_task_service.py",
                    "tests/test_task_model.py"
                ])
            ]
            
            overall_success = True
            
            for batch_name, test_files in test_batches:
                batch_success = self.run_test_batch(batch_name, test_files)
                overall_success &= batch_success
            
            # 4. 生成报告
            report_file = self.generate_report()
            
            # 5. 显示最终结果
            print("\n🎉 Mac开发环境测试完成!")
            status = "✅ 成功" if overall_success else "❌ 有失败项"
            print(f"总体状态: {status}")
            print(f"详细报告: {report_file}")
            
            return overall_success
            
        finally:
            self.cleanup()

if __name__ == '__main__':
    runner = MacTestRunner()
    success = runner.run_all_tests()
    sys.exit(0 if success else 1)
```

---

## 📋 第三阶段：Windows兼容性准备

### 跨平台代码检查清单
```python
# 创建文件：tools/cross_platform_checker.py
import ast
import os
from pathlib import Path
from typing import List, Dict

class CrossPlatformChecker:
    """跨平台兼容性检查工具"""
    
    def __init__(self):
        self.issues = []
    
    def check_file_paths(self, file_path: str):
        """检查文件路径使用"""
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # 检查硬编码路径
        if '/' in content and not content.startswith('#!'):
            # 检查是否使用了Unix风格路径
            lines = content.split('\n')
            for i, line in enumerate(lines, 1):
                if ('/' in line and 
                    not line.strip().startswith('#') and 
                    not 'http' in line and
                    not 'Path(' in line and
                    not 'os.path.join' in line):
                    
                    self.issues.append({
                        'file': file_path,
                        'line': i,
                        'type': 'path_separator',
                        'content': line.strip(),
                        'suggestion': '使用 Path() 或 os.path.join()'
                    })
    
    def check_serial_imports(self, file_path: str):
        """检查串口相关导入"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                tree = ast.parse(f.read())
            
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        if 'serial' in alias.name:
                            # 检查是否有平台特定处理
                            pass
                            
        except SyntaxError:
            pass
    
    def generate_compatibility_report(self, source_dir: str) -> str:
        """生成兼容性报告"""
        print("🔍 检查跨平台兼容性...")
        
        py_files = list(Path(source_dir).rglob('*.py'))
        
        for py_file in py_files:
            self.check_file_paths(str(py_file))
            self.check_serial_imports(str(py_file))
        
        # 生成报告
        report = f"""# 跨平台兼容性检查报告

## 检查文件数量: {len(py_files)}

## 发现的问题: {len(self.issues)}

"""
        
        for issue in self.issues:
            report += f"""### {issue['file']}:{issue['line']}
- 类型: {issue['type']}
- 内容: `{issue['content']}`
- 建议: {issue['suggestion']}

"""
        
        return report

if __name__ == '__main__':
    checker = CrossPlatformChecker()
    report = checker.generate_compatibility_report('.')
    
    with open('temp/logs/cross_platform_report.md', 'w', encoding='utf-8') as f:
        f.write(report)
    
    print("📄 兼容性报告已生成: temp/logs/cross_platform_report.md")
```

---

## 🚀 使用指南

### 立即开始（推荐流程）

```bash
# 1. 环境准备
chmod +x setup_mac_dev_environment.sh
./setup_mac_dev_environment.sh

# 2. 启动开发环境
source catpool_env/bin/activate
cp .env.mac .env

# 3. 启动模拟器（新终端）
python tests/mac_serial_simulator.py

# 4. 运行第一批测试
python run_mac_tests.py

# 5. 启动应用进行手工测试
python app.py
```

### 提交给Claude的建议

每完成一个批次的测试，您可以提交：

1. **📁 相关代码文件** - 当前批次涉及的所有Python文件
2. **📊 测试报告** - `temp/logs/mac_test_report_*.md`
3. **🐛 问题列表** - 发现的具体错误和日志
4. **❓ 具体问题** - 需要解决的技术问题

这样我就能帮您：
- 🔧 修复Mac平台特定的问题
- 🎨 改进代码结构和性能
- 🛡️ 增强错误处理
- 📚 提供Windows适配建议

您准备好开始了吗？建议从**基础环境验证**开始！